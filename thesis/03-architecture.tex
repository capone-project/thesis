\section{Architecture}

\tikzset{
    host/.style={
        draw,
        rectangle
    },
    switch/.style={
        draw,
        rectangle
    },
    hwslave/.style={
        draw,
        rectangle
    },
    appslave/.style={
        draw,
        ellipse
    },
    netlink/.style={
        draw,
        line width=0.4mm,
        triangle 45-triangle 45
    }
}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}
        \node[host] (host) {HOST};
        \node[switch,above=of host] (switch) {SWITCH};

        \node[hwslave,above=4cm of switch] (network) {NETWORK};
        \node[draw,cloud,above=1cm of network] (inet) {INET};

        \node[hwslave,left=2cm of switch,yshift=+1.0cm] (mouse)    {MOUSE};
        \node[hwslave,left=2cm of switch,yshift=+2.0cm] (keyboard) {KEYBOARD};
        \node[hwslave,left=2cm of switch,yshift=+3.0cm] (storage)  {STORAGE};
        \node[hwslave,left=2cm of switch,yshift=+4.0cm] (gpu)      {GPU};

        \node[appslave,right=2cm of switch,yshift=+1.0cm] (app1) {APP1};
        \node[appslave,right=2cm of switch,yshift=+2.0cm] (app2) {APP2};
        \node[right=2cm of switch,yshift=+3.0cm]          (appi) {$\ldots$};
        \node[appslave,right=2cm of switch,yshift=+4.0cm] (appn) {APP$n$};

        \path[netlink] (host) to (switch.south);

        \path[netlink] (switch) to (network);
        \path[netlink] (network) to (inet);

        \path[netlink] ([xshift=0.00cm]switch.north west) |- (mouse.east);
        \path[netlink] ([xshift=0.25cm]switch.north west) |- (keyboard.east);
        \path[netlink] ([xshift=0.50cm]switch.north west) |- (storage.east);
        \path[netlink] ([xshift=0.75cm]switch.north west) |- (gpu.east);

        \path[netlink]        ([xshift=-0.00cm]switch.north east) |- (app1.west);
        \path[netlink]        ([xshift=-0.25cm]switch.north east) |- (app2.west);
        \path[netlink,dashed] ([xshift=-0.50cm]switch.north east) |- (appi.west);
        \path[netlink]        ([xshift=-0.75cm]switch.north east) |- (appn.west);
    \end{tikzpicture}

    \caption{Architecture}
\end{figure}

\subsection{Connection flowchart}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}
        [
            line/.style = {
                draw,
                -latex'
            },
            block/.style = {
                rectangle,
                draw,
                fill=blue!20,
                text width=5em,
                text centered,
                rounded corners,
                minimum height=4em
            },
            decision/.style = {
                diamond,
                draw,
                fill=blue!20,
                text width=4.5em,
                text badly centered,
                inner sep=0pt
            }
        ]

        \node[block] (attach) {App attaches};
        \node[block,below=of attach] (announce) {App announces};
        \node[decision,below=of announce] (satisfiable) {Reqs satisfiable?};
        \node[block,right=of satisfiable] (unsatisfied) {Fail due to unsatisfiability};
        \node[block,below=of satisfiable] (askpeers) {Notify peer devices};
        \node[decision,below=of askpeers] (ack) {All devs acknowledge?};
        \node[block,right=of ack] (nack) {Fail due to nack};
        \node[block,below=of ack] (start) {Notify app of start};
        \node[block,below=of start] (negotiate) {Negotiate secure connections with peers};
        \node[block,below=of negotiate] (run) {Run};

        \path[line] (attach) -- (announce);
        \path[line] (announce) -- (satisfiable);
        \path[line] (satisfiable) -- node[near start,below] {no?} (unsatisfied);
        \path[line] (satisfiable) -- node[near start,right] {yes?} (askpeers);
        \path[line] (askpeers) -- (ack);
        \path[line] (ack) -- node[near start,below] {no?} (nack);
        \path[line] (ack) -- node[near start,right] {yes?} (start);
        \path[line] (start) -- (negotiate);
        \path[line] (negotiate) -- (run);
    \end{tikzpicture}

    \caption{Connecting an app}
\end{figure}

\subsection{Message Diagrams}

\subsubsection{Discovery}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Server}

        \mess{c}{Discover}{s}
        \draw (Discover from) -- (Discover to) node[midway,below]
            {$sk_c(\text{version}, \text{listening port}) \| pk_c$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Announce}{c}
        \draw (Announce from) -- (Announce to) node[midway,below]
            {$pk_c(sk_s(\text{version}, \text{listening port}, \text{name}) \| pk_s$)};

        \postlevel
    \end{sequencediagram}
    \caption{Undirected Service Discovery Messaging Chart}
\end{figure}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Server}

        \mess{c}{Discover}{s}
        \draw (Discover from) -- (Discover to) node[midway,below]
            {$pk_s(sk_c(\text{version}, \text{listening port}) \| pk_c$)};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Announce}{c}
        \draw (Announce from) -- (Announce to) node[midway,below]
            {$pk_c(sk_s(\text{version}, \text{listening port}, \text{name}) \| pk_s$)};

        \postlevel
    \end{sequencediagram}
    \caption{Directed Service Discovery Messaging Chart}
\end{figure}

\subsubsection{Handshake}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Server}

        \mess{c}{Probe}{s}
        \draw (Probe from) -- (Probe to) node[midway,below]
            {$pk_s(\text{Probe})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Service Description}{c}
        \draw (Service Description from) -- (Service Description to) node[midway,below]
            {$pk_c(\text{name}, \text{addresses}, \text{location}, \text{type}, \text{parameters}, \text{status})$};

        \postlevel
    \end{sequencediagram}
    \caption{Probe Messaging Chart}
\end{figure}

\subsubsection{Connection}

\begin{align*}
    \text{capability} \coloneqq pk_s(\text{sessionid}, \text{parameters})
\end{align*}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Server}

        \mess{c}{Connection Request}{s}
        \draw (Connection Request from) -- (Connection Request to) node[midway,below]
            {$pk_s(\text{parameters}, \text{secret})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Connection Capability}{c}
        \draw (Connection Capability from) -- (Connection Capability to) node[midway,below]
            {$pk_c(\text{sessionid}, \text{capability})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{c}{Connect}{s}
        \draw (Connect from) -- (Connect to) node[midway,below]
            {$pk_s(\text{sessionid}, \text{capability})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Connect OK}{c}
    \end{sequencediagram}
    \caption{Direct Connect}
\end{figure}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{o}{Other Server}
        \newinst[4]{c}{Client}
        \newinst[4]{s}{Server}

        \mess{c}{Connection Request}{s}
        \postlevel
        \mess{s}{Connection Capability}{c}

        \postlevel
        \postlevel

        \mess{c}{Connection Request}{o}
        \postlevel
        \mess{o}{Connection Capability}{c}
        \postlevel
        \mess{c}{Connect}{o}

        \postlevel
        \postlevel

        \mess{o}{Connect}{s}
        \postlevel
        \mess{s}{Connect OK}{o}
    \end{sequencediagram}
    \caption{Relayed Connect}
\end{figure}

\subsection{Notes}

\begin{itemize}
    \item host has graphic server
    \item only knows about window extents, not contents due to encryption
    \item initially gets all keyboard/mouse inputs
    \item upon mouse enter inside a window, notifies mouse server of window extents
    \item mouse server keeps track of relative mouse position, notifies server upon exit of extents
    \item window server registers shortcuts that are required for window changing
    \item shortcuts may NEVER be rebound by client applications

    \item you can attach and reattach apps to other devices without any problems!!!
    \item overlay in server manager when app is connected and reqs are not fulfilled
    \item one container may run multiple apps
        \begin{itemize}
            \item clustering based on security level
        \end{itemize}
\end{itemize}

% vim: ft=tex tw=0
