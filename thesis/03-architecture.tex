\section{Architecture}

\tikzset{
    host/.style={
        draw,
        rectangle
    },
    switch/.style={
        draw,
        rectangle
    },
    hwslave/.style={
        draw,
        rectangle
    },
    appslave/.style={
        draw,
        ellipse
    },
    netlink/.style={
        draw,
        line width=0.4mm,
        triangle 45-triangle 45
    }
}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}
        \node[host] (host) {HOST};
        \node[switch,above=of host] (switch) {SWITCH};

        \node[hwslave,above=4cm of switch] (network) {NETWORK};
        \node[draw,cloud,above=1cm of network] (inet) {INET};

        \node[hwslave,left=2cm of switch,yshift=+1.0cm] (mouse)    {MOUSE};
        \node[hwslave,left=2cm of switch,yshift=+2.0cm] (keyboard) {KEYBOARD};
        \node[hwslave,left=2cm of switch,yshift=+3.0cm] (storage)  {STORAGE};
        \node[hwslave,left=2cm of switch,yshift=+4.0cm] (gpu)      {GPU};

        \node[appslave,right=2cm of switch,yshift=+1.0cm] (app1) {APP1};
        \node[appslave,right=2cm of switch,yshift=+2.0cm] (app2) {APP2};
        \node[right=2cm of switch,yshift=+3.0cm]          (appi) {$\ldots$};
        \node[appslave,right=2cm of switch,yshift=+4.0cm] (appn) {APP$n$};

        \path[netlink] (host) to (switch.south);

        \path[netlink] (switch) to (network);
        \path[netlink] (network) to (inet);

        \path[netlink] ([xshift=0.00cm]switch.north west) |- (mouse.east);
        \path[netlink] ([xshift=0.25cm]switch.north west) |- (keyboard.east);
        \path[netlink] ([xshift=0.50cm]switch.north west) |- (storage.east);
        \path[netlink] ([xshift=0.75cm]switch.north west) |- (gpu.east);

        \path[netlink]        ([xshift=-0.00cm]switch.north east) |- (app1.west);
        \path[netlink]        ([xshift=-0.25cm]switch.north east) |- (app2.west);
        \path[netlink,dashed] ([xshift=-0.50cm]switch.north east) |- (appi.west);
        \path[netlink]        ([xshift=-0.75cm]switch.north east) |- (appn.west);
    \end{tikzpicture}

    \caption{Architecture}
\end{figure}

\subsection{Connection flowchart}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}
        [
            line/.style = {
                draw,
                -latex'
            },
            block/.style = {
                rectangle,
                draw,
                fill=blue!20,
                text width=5em,
                text centered,
                rounded corners,
                minimum height=4em
            },
            decision/.style = {
                diamond,
                draw,
                fill=blue!20,
                text width=4.5em,
                text badly centered,
                inner sep=0pt
            }
        ]

        \node[block] (attach) {App attaches};
        \node[block,below=of attach] (announce) {App announces};
        \node[decision,below=of announce] (satisfiable) {Reqs satisfiable?};
        \node[block,right=of satisfiable] (unsatisfied) {Fail due to unsatisfiability};
        \node[block,below=of satisfiable] (askpeers) {Notify peer devices};
        \node[decision,below=of askpeers] (ack) {All devs acknowledge?};
        \node[block,right=of ack] (nack) {Fail due to nack};
        \node[block,below=of ack] (start) {Notify app of start};
        \node[block,below=of start] (negotiate) {Negotiate secure connections with peers};
        \node[block,below=of negotiate] (run) {Run};

        \path[line] (attach) -- (announce);
        \path[line] (announce) -- (satisfiable);
        \path[line] (satisfiable) -- node[near start,below] {no?} (unsatisfied);
        \path[line] (satisfiable) -- node[near start,right] {yes?} (askpeers);
        \path[line] (askpeers) -- (ack);
        \path[line] (ack) -- node[near start,below] {no?} (nack);
        \path[line] (ack) -- node[near start,right] {yes?} (start);
        \path[line] (start) -- (negotiate);
        \path[line] (negotiate) -- (run);
    \end{tikzpicture}

    \caption{Connecting an app}
\end{figure}

\subsection{Low-level protocol}

The low-level protocol determines how the actual packets sent between client and server are constructed.
It specifies a common format independent of the actual transport layer that is used to guarantee a common understanding of how to handle incoming bytes.
The protocol is currently designed to be used over either TCP or UDP but should be generic enough to be used for other transport layers.
We will concentrate on describing design choices based on TCP and UDP transport layours only, though.

The major difference between TCP and UDP is that TCP is stream based and UDP is packet based.
This means that UDP packages have their size attached to the package itself, so it is guaranteed that when receiving a single package over UDP we know package boundaries and thus can split incoming packages by these boundaries.
On TCP this is not true, though, so we need to design a package format which is able to specify package boundaries so the client is able to determine a unit.

The initial design simply prefixed every single package with an unencrypted package length fixed to four bytes in network byte order.
This allowed the client to initially receive four bytes, convert these to host byte order and subsequently receive the amount of bytes specified.
While easy to implement this has several disadvantages.

The most obvious disadvantage is that the package length was always transmitted unencrypted.
It would have been possible to always encrypt the length with an attached message authentication code so that it is impossible to tamper with the length, but this would require us to always add the additional overhead of the attached MAC.
But even if the length was encrypted the attacker could be able to guess contents of sent packages based on their package lengths only.
Especially the package length packages will always be of fixed size universally known to all clients such that they are able to fetch the exact amount of bytes required to obtain the length of the follow package data.
Due to this shortcoming it becomes much easier for the adversary to do traffic analysis based on package sizes.

Another minor disadvantage is based on performance.
Assumed a single big package is sent over the wire.
With the simple case of an encrypted connection between client and server the client would be required to fetch the whole package before he is able to actually decrypt its content.
As the network layer is slow compared to doing computations on locally available data it would be of advantage to decrypt arriving data while waiting for subsequent bytes to arrive.
This would decrease the overall time required to receive and decrypt a big package.

To fix these problems the implementation resorts to packages of a fixed length.
The initial fixed-length package is prefixed with the overall length of the assembled package.
If the overall length exceeds the length of the remaining bytes of the first fixed length package, then the complete package is assembled by concatenating the first package all subsequent packages until the desired length is received.
The package length is only encoded in the first split package and all split packages are encrypted on their own.
The last package is right-padded with zeroes until it is as big as the other packages.

The following example demonstrates the package format for unencrypted packages.
We assume a fixed length package size of 64 bytes.
If a party now wishes to transfer a complete package of 80 bytes the complete package will get split into two partial packets.
The first package would be prefixed with four bytes of the complete package length and filled with the initial $64 - 4 = 60$ bytes.
The second package is filled with the remaining $80 - 60 = 20$ bytes and right-padded with $64 - 20 = 44$ zeroes.
Figure \ref{fig:unencrypted-package-format} visualizes both package contents.

\begin{figure}
    \center

    \begin{tikzpicture}[
            every node/.style={ minimum width=6mm, minimum height=8mm },
            start chain=1 going right,
            start chain=2 going right,
            node distance=-0.15mm
        ]

        \node[draw, on chain=1, minimum width=6mm] {l};
        \node[draw, on chain=1, minimum width=90mm] {60 bytes of data};
        \node[left=1cm of 1-1] {Package 1};

        \node[draw, on chain=2, minimum width=48mm, below=1cm of 1-1.west, anchor = west] {20 bytes of data};
        \node[draw, on chain=2, minimum width=48mm] {padding};
        \node[left=1cm of 2-1] {Package 2};
    \end{tikzpicture}

    \caption{Unencrypted package format}
    \label{fig:unencrypted-package-format}
\end{figure}

The second example (see figure \ref{fig:encrypted-package-format}) demonstrates how encrypted packages work.
In contrast to unencrypted packages there is an additional message authentication code attached to each split package which is now assumed to be 16 bytes long.

\begin{figure}
    \center

    \begin{tikzpicture}[
            every node/.style={ minimum width=6mm, minimum height=8mm },
            start chain=1 going right,
            start chain=2 going right,
            node distance=-0.15mm
        ]

        \node[draw, on chain=1, minimum width=24mm] {MAC};
        \node[draw, on chain=1, minimum width=6mm ] {l};
        \node[draw, on chain=1, minimum width=66mm] {44 bytes data};
        \node[left=1cm of 1-1] {Package 1};

        \node[draw, on chain=2, minimum width=24mm, below=1cm of 1-1.west, anchor = west] {MAC};
        \node[draw, on chain=2, minimum width=54mm] {36 bytes data};
        \node[draw, on chain=2, minimum width=18mm] {padding};
        \node[left=1cm of 2-1] {Package 2};

        \draw [decorate,decoration={brace,amplitude=10pt}] (1-2.north west) -- (1-3.north east) node[midway,yshift=7mm] {encrypted};
        \draw [decorate,decoration={brace,amplitude=10pt,mirror}] (2-2.south west) -- (2-3.south east) node[midway,yshift=-7mm] {encrypted};
    \end{tikzpicture}

    \caption{Encrypted package format}
    \label{fig:encrypted-package-format}
\end{figure}

On the client side to process the split packages we will fetch the initial fixed-size package.
If the connection is encrypted, we will check the decrypt the message and verify the message authentication code.
Now we inspect the first four bytes to gain knowledge about the total package length -- if it exceeds the amount of bytes sent in the initial message, we will receive, verify and decrypt all following packages until all bytes are received.
Finally, we concatenate all content together to obtain the complete package.

\subsection{Connection establishment}

\begin{figure}
    \centering

    \begin{sequencediagram}
        \newthread{c}{Client (Verify$_c$, Sign$_c$)}
        \newinst[4]{s}{Server (VerifyS, SignS)}

        \begin{messcall}{c}{ConnectionType}{s}
            \postlevel

            \begin{call}{c}{GenerateKeypair()}{c}{(Enc$_c$, Dec$_c$)}
                \postlevel
            \end{call}

            \prelevel
            \prelevel
            \prelevel

            \begin{call}{s}{GenerateKeypair()}{s}{(Enc$_s$, Dec$_s$)}
                \postlevel
            \end{call}

            \postlevel

            \mess{c}{VerifyC, EncC, Signature}{s}
            \mess{s}{VerifyS, EncS, Signature}{c}

            \postlevel

            \begin{call}{c}{EphemeralKey(EncC, DecC, EncS)}{c}{Key}
                \postlevel
            \end{call}

            \prelevel
            \prelevel
            \prelevel

            \begin{call}{s}{EphemeralKey(EncS, DecS, EncC)}{s}{Key}
                \postlevel
            \end{call}

            \postlevel

            \mess{c}{Signature of Key}{s}
            \mess{s}{Signature of Key}{c}
        \end{messcall}
    \end{sequencediagram}

    \caption{Connection establishment}
    \label{fig:connection-establishment}
\end{figure}

\subsection{Message Diagrams}

\subsubsection{Discovery}

Device discovery is the process of discovering previously unknown services in a certain subnet.
To achieve the discovery, a client has to query all possible addresses in this subnet and subsequently await responses from servers.
This can easily be achieved with UDP multicast, that is we send a message to the multicast address of the subnet.
As UDP is port based it is mandatory that we choose a well-known port in advance to the protocol as otherwise it would be impossible to bootstrap the initial communication.

There are two major distinctions on how service discovery can be achieved: a client- and a service-driven approach.
The service-driven is based on the service periodically sending an announce message to the multicast address, thereby notifying possibly listening clients of the availability of a certain service.

The client-driven approach on the other side lets the client query the subnet for existing services by announcing that it wants to know about available services.
Every service that is listening and that receives this request will then answer the client and announce its presence.

Both methods have their own merit.
Periodic announcements of the service conceal the intent of clients to discover local services as they are not directly involved in the process of finding services.
They have the disadvantage of additional overhead, though, as we regularly have to announce our service.
While this might not be problematic when only few services are available in a certain subnet it may become unwieldy when hundreds of services are present.

This disadvantage is mitigated by the probing approach by clients that want to discover nearby services.
Just how important this is gets particularly clear when we consider the process how users want to start interacting with a certain service.
Assume that a user starts up his mobile phone with our app with the intent to start using a certain service.
With the periodic probing approach the user will in the worst case have to wait for the whole time span between two announcements of the service he wants to connect to.
Depending on how this timeout was chosen this may be an uncomfortably long time.
As users are generally uncomfortable with doing nothing for a rather long time (CITATION NEEDED) they might simply stop waiting and just scrap their plan.

When we directly probe the subnet for available services instead the response times will in the mean case be much less than in the other case.
That is the delay of services popping up is only based on latency and processing time of both service and client.
As a consequence we have chosen the probing approach.\\

The initial exchange between a client and service which have never seen each other before is somewhat problematic, as in general we cannot establish the authenticity of either one.
To accomodate for this we distinguish between undirected (see figure \ref{fig:undirected-service-discovery}) and directed service discovery(see figure \ref{fig:directed-service-discovery}).
While the undirected discovery protocol is unauthenticated we are able to improve the situation for directed service discovery in certain cases.

Through a sidechannel we are able to retrieve additional data about a service we want to connect to.
As described by McCune et al. \cite{mccune2005seeing} we can establish additional trust amongst other things by scanning a QR code that is either printed on the case of the service or, further improving the trust level, by dynamically displaying a QR code on the screen.
This is particularly interesting in the case where we want to connect to a display service.
Upon notifying the service in a certain out-of-band way (e.g. by pressing a certain button on the display) it will generate a QR code and display it on the screen.
The client can subsequently scan the code and in such a way retrieve information like the public key and address of the display.
As soon as we have obtained data through this side channel we are able to verify authenticity of the service we are communicating with, assuming the side channel has not been compromised.

Let us now consider the actual discovery protocol.

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Service}

        \mess{c}{Discover}{s}
        \draw (Discover from) -- (Discover to) node[midway,below]
            {$
                \begin{aligned}
                    m \leftarrow &\{\text{version}, \text{port}, pk_c\}\\
                    t \leftarrow &S_{sk_c}(m)\\
                                 &\text{send}(m \| t)
                \end{aligned}
            $};

        \postlevel
        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Announce}{c}
        \draw (Announce from) -- (Announce to) node[midway,below]
            {$
                \begin{aligned}
                    \text{services} \coloneqq &[ (port, type) ]\\
                    m \leftarrow &\{\text{version}, \text{name}, \text{services}, pk_s\}\\
                    t \leftarrow &S_{sk_p}(m)\\
                                 &\text{send}(\text{Enc}_{pk_c}(m \| t))
                \end{aligned}
            $};

        \postlevel
        \postlevel
        \postlevel
        \postlevel
    \end{sequencediagram}

    \caption{Undirected Service Discovery Messaging Chart}
    \label{fig:undirected-service-discovery}
\end{figure}

We assume both client and service own a long term key pair $(pk_c, sk_c)$ and $(pk_s, sk_s)$, respectively, that is used for establishing their own identity.
The initial \emph{Discover} message contains a protocol version, port and the public key of the client.

The version is required as future iterations on the protocol may lead to incompatibilities between different versions of the software stack that is in use on both client and service.
It is of utmost importance to check those versions for both parties to avoid running into incompatibilities that may cause the protocol to seemingly work while in fact it is broken in a subtle way.

When the service receives a UDP message the originating address is recorded in this message.
When we want to respond to that message, though, we are not able to do so without also knowing which port to send that response to, as UDP is a connection-less protocol.
As such we include a listing port inside the initial message that will be used by the service to send the response message.

Last we also include the client's long term public key to establish the client's identity and which will be used in future exchanges to encrypt further messages.
The whole message is then signed by the client and sent to the service.\\

On the receiving side we first unpack the message to retrieve version, port and public key.
With the public key and the message's tag we are now able to verify the integrity of the received package.
Obviously, though, we are not able to say anything about the authenticity about it as it could have been intercepted by a malicious third party, exchanging the message tag and public key.

After establishing message integrity the service will now compare the client's version to its own version and only proceed if he is able to correctly service that version.
He will then assemble a response package containing its own version, name, available local services and its public key.

It is possible for a single server to announce multiple services.
Those services may be distinguished by the port they are listenging at.
Instead of announcing multiple service types at a single port, which would then require multiplexing requests to their respective service and thus introduce additional complexity, each service has its own port which will later be used to connect to that service.

% TODO: encrypt message with public key?
The server will now again generate a message tag and send both message and tag encrypted with the public key of the client to the client's listening port that has been previously announced.

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Service}

        \mess{c}{Discover}{s}
        \draw (Discover from) -- (Discover to) node[midway,below]
            {$
                \begin{aligned}
                    m \leftarrow &\{\text{version}, \text{port}, pk_c\}\\
                    t \leftarrow &S_{sk_c}(m)\\
                                 &\text{send}(\text{Enc}_{pk_s}(m \| t))
                \end{aligned}
            $};

        \postlevel
        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Announce}{c}
        \draw (Announce from) -- (Announce to) node[midway,below]
            {$
                \begin{aligned}
                    \text{services} \coloneqq &[ (port, type) ]\\
                    m \leftarrow &\{\text{version}, \text{name}, \text{services}, pk_s\}\\
                    t \leftarrow &S_{sk_p}(m)\\
                                 &\text{send}(\text{Enc}_{pk_c}(m \| t))
                \end{aligned}
            $};

        \postlevel
        \postlevel
        \postlevel
        \postlevel
    \end{sequencediagram}

    \caption{Directed Service Discovery Messaging Chart}
    \label{fig:directed-service-discovery}
\end{figure}

In contrast to the indirected service discovery, there is only one significant difference in the directed service discovery.
As we have previously obtained public key data of the server we want to talk to we are already able to use its key to encrypt the first message.
That is instead of sending $m \| t$ in the fisrt step, we send $\text{Enc}_{pk_s}(m \| t)$.
Like this it is impossible to tamper with the first message in such a way that the receiver retrieves a valid message with invalid key data.

All subsequent steps remain unchanged.

\subsubsection{Handshake}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Server}

        \mess{c}{Probe}{s}
        \draw (Probe from) -- (Probe to) node[midway,below]
            {$pk_s(pk_c)$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Service Description}{c}
        \draw (Service Description from) -- (Service Description to) node[midway,below]
            {$pk_c(\text{name}, \text{addresses}, \text{location}, \text{type}, \text{parameters}, \text{status})$};

        \postlevel
    \end{sequencediagram}
    \caption{Probe Messaging Chart}
\end{figure}

\subsubsection{Connection}

\begin{align*}
    \text{capability} \coloneqq pk_s(\text{sessionid}, \text{parameters})
\end{align*}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Server}

        \mess{c}{Ephemeral Key Generation}{s}
        \mess{s}{}{c}

        \postlevel
        \postlevel
        \postlevel

        \mess{c}{Connection Request}{s}
        \draw (Connection Request from) -- (Connection Request to) node[midway,below]
            {$pk_s(pk_c, \text{parameters})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Connection Capability}{c}
        \draw (Connection Capability from) -- (Connection Capability to) node[midway,below]
            {$pk_c(\text{sessionid})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{c}{Connect}{s}
        \draw (Connect from) -- (Connect to) node[midway,below]
            {$pk_s(\text{sessionid})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Connect OK}{c}
    \end{sequencediagram}
    \caption{Direct Connect}
\end{figure}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{o}{CPU Server}
        \newinst[4]{c}{Client}
        \newinst[4]{s}{Server}

        \mess{c}{Connection Request}{s}
        \postlevel
        \mess{s}{Connection Capability}{c}

        \postlevel
        \postlevel

        \mess{c}{Connection Request}{o}
        \postlevel
        \mess{o}{Connection Capability}{c}
        \postlevel
        \mess{c}{Connect}{o}

        \postlevel
        \postlevel

        \mess{o}{Connect}{s}
        \postlevel
        \mess{s}{Connect OK}{o}
        \postlevel
        \mess{o}{Connect OK}{c}
    \end{sequencediagram}
    \caption{Relayed Connect}
\end{figure}

\subsection{Capability Service}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newthread{r}{Requester r}
        \newinst[2]{e}{Entity e}
        \newinst[2]{s}{Service s}
        \newinst[2]{c}{Capability Server}

        \mess{e}{Register}{c}
        \postlevel

        \begin{call}{r}{Request(e, s, params)}{c}{Service Session}
            \postlevel
            \begin{call}{c}{Ask(r, s, params)}{e}{Service Session}
                \postlevel
                \begin{call}{e}{Initiate(params)}{s}{Service Session}
                \end{call}
                \postlevel
            \end{call}
            \postlevel
        \end{call}

        \postlevel

        \begin{messcall}{r}{Start}{s}
            \postlevel
        \end{messcall}

        \prelevel
    \end{sequencediagram}
    \caption{Capability Request}
\end{figure}

\subsection{Invoke Service}

\begin{figure}[H]
    \centering
    \begin{sequencediagram}
        \newthread{c}{Client}
        \newinst[3]{s}{Service}
        \newinst[3]{i}{Invoker}

        \begin{call}{c}{Initiate(Parameters)}{s}{Service Session}
            \begin{call}{s}{CreateSession()}{s}{Session}
            \end{call}
        \end{call}

        \postlevel

        \begin{call}{c}{Initiate(ServiceSession)}{i}{Invoker Session}
            \begin{call}{i}{CreateSession()}{i}{Session}
            \end{call}
        \end{call}
        \postlevel

        \begin{messcall}{c}{Start}{i}
            \begin{messcall}{i}{Start}{s}
                \postlevel
            \end{messcall}
            \prelevel
        \end{messcall}
        \prelevel
    \end{sequencediagram}

    \caption{Invoke Service}
\end{figure}

\subsection{Notes}

\begin{itemize}
    \item host has graphic server
    \item only knows about window extents, not contents due to encryption
    \item initially gets all keyboard/mouse inputs
    \item upon mouse enter inside a window, notifies mouse server of window extents
    \item mouse server keeps track of relative mouse position, notifies server upon exit of extents
    \item window server registers shortcuts that are required for window changing
    \item shortcuts may NEVER be rebound by client applications

    \item you can attach and reattach apps to other devices without any problems!!!
    \item overlay in server manager when app is connected and reqs are not fulfilled
    \item one container may run multiple apps
        \begin{itemize}
            \item clustering based on security level
        \end{itemize}
\end{itemize}

% vim: ft=tex tw=0
