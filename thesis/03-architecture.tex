\section{Architecture}

\tikzset{
    host/.style={
        draw,
        rectangle
    },
    switch/.style={
        draw,
        rectangle
    },
    hwslave/.style={
        draw,
        rectangle
    },
    appslave/.style={
        draw,
        ellipse
    },
    netlink/.style={
        draw,
        line width=0.4mm,
        triangle 45-triangle 45
    }
}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}
        \node[host] (host) {HOST};
        \node[switch,above=of host] (switch) {SWITCH};

        \node[hwslave,above=4cm of switch] (network) {NETWORK};
        \node[draw,cloud,above=1cm of network] (inet) {INET};

        \node[hwslave,left=2cm of switch,yshift=+1.0cm] (mouse)    {MOUSE};
        \node[hwslave,left=2cm of switch,yshift=+2.0cm] (keyboard) {KEYBOARD};
        \node[hwslave,left=2cm of switch,yshift=+3.0cm] (storage)  {STORAGE};
        \node[hwslave,left=2cm of switch,yshift=+4.0cm] (gpu)      {GPU};

        \node[appslave,right=2cm of switch,yshift=+1.0cm] (app1) {APP1};
        \node[appslave,right=2cm of switch,yshift=+2.0cm] (app2) {APP2};
        \node[right=2cm of switch,yshift=+3.0cm]          (appi) {$\ldots$};
        \node[appslave,right=2cm of switch,yshift=+4.0cm] (appn) {APP$n$};

        \path[netlink] (host) to (switch.south);

        \path[netlink] (switch) to (network);
        \path[netlink] (network) to (inet);

        \path[netlink] ([xshift=0.00cm]switch.north west) |- (mouse.east);
        \path[netlink] ([xshift=0.25cm]switch.north west) |- (keyboard.east);
        \path[netlink] ([xshift=0.50cm]switch.north west) |- (storage.east);
        \path[netlink] ([xshift=0.75cm]switch.north west) |- (gpu.east);

        \path[netlink]        ([xshift=-0.00cm]switch.north east) |- (app1.west);
        \path[netlink]        ([xshift=-0.25cm]switch.north east) |- (app2.west);
        \path[netlink,dashed] ([xshift=-0.50cm]switch.north east) |- (appi.west);
        \path[netlink]        ([xshift=-0.75cm]switch.north east) |- (appn.west);
    \end{tikzpicture}

    \caption{Architecture}
\end{figure}

\subsection{Connection flowchart}

\begin{figure}[H]
    \centering

    \begin{tikzpicture}
        [
            line/.style = {
                draw,
                -latex'
            },
            block/.style = {
                rectangle,
                draw,
                fill=blue!20,
                text width=5em,
                text centered,
                rounded corners,
                minimum height=4em
            },
            decision/.style = {
                diamond,
                draw,
                fill=blue!20,
                text width=4.5em,
                text badly centered,
                inner sep=0pt
            }
        ]

        \node[block] (attach) {App attaches};
        \node[block,below=of attach] (announce) {App announces};
        \node[decision,below=of announce] (satisfiable) {Reqs satisfiable?};
        \node[block,right=of satisfiable] (unsatisfied) {Fail due to unsatisfiability};
        \node[block,below=of satisfiable] (askpeers) {Notify peer devices};
        \node[decision,below=of askpeers] (ack) {All devs acknowledge?};
        \node[block,right=of ack] (nack) {Fail due to nack};
        \node[block,below=of ack] (start) {Notify app of start};
        \node[block,below=of start] (negotiate) {Negotiate secure connections with peers};
        \node[block,below=of negotiate] (run) {Run};

        \path[line] (attach) -- (announce);
        \path[line] (announce) -- (satisfiable);
        \path[line] (satisfiable) -- node[near start,below] {no?} (unsatisfied);
        \path[line] (satisfiable) -- node[near start,right] {yes?} (askpeers);
        \path[line] (askpeers) -- (ack);
        \path[line] (ack) -- node[near start,below] {no?} (nack);
        \path[line] (ack) -- node[near start,right] {yes?} (start);
        \path[line] (start) -- (negotiate);
        \path[line] (negotiate) -- (run);
    \end{tikzpicture}

    \caption{Connecting an app}
\end{figure}

\subsection{Message Diagrams}

\subsubsection{Discovery}

Device discovery is the process of discovering previously unknown services in a certain subnet.
To achieve the discovery, a client has to query all possible addresses in this subnet and subsequently await responses from servers.
This can easily be achieved with UDP multicast, that is we send a message to the multicast address of the subnet.
As UDP is port based it is mandatory that we choose a well-known port in advance to the protocol as otherwise it would be impossible to bootstrap the initial communication.

There are two major distinctions on how service discovery can be achieved: a client- and a service-driven approach.
The service-driven is based on the service periodically sending an announce message to the multicast address, thereby notifying possibly listening clients of the availability of a certain service.

The client-driven approach on the other side lets the client query the subnet for existing services by announcing that it wants to know about available services.
Every service that is listening and that receives this request will then answer the client and announce its presence.

Both methods have their own merit.
Periodic announcements of the service conceal the intent of clients to discover local services as they are not directly involved in the process of finding services.
They have the disadvantage of additional overhead, though, as we regularly have to announce our service.
While this might not be problematic when only few services are available in a certain subnet it may become unwieldy when hundreds of services are present.

This disadvantage is mitigated by the probing approach by clients that want to discover nearby services.
Just how important this is gets particularly clear when we consider the process how users want to start interacting with a certain service.
Assume that a user starts up his mobile phone with our app with the intent to start using a certain service.
With the periodic probing approach the user will in the worst case have to wait for the whole time span between two announcements of the service he wants to connect to.
Depending on how this timeout was chosen this may be an uncomfortably long time.
As users are generally uncomfortable with doing nothing for a rather long time (CITATION NEEDED) they might simply stop waiting and just scrap their plan.

When we directly probe the subnet for available services instead the response times will in the mean case be much less than in the other case.
That is the delay of services popping up is only based on latency and processing time of both service and client.
As a consequence we have chosen the probing approach.\\

The initial exchange between a client and service which have never seen each other before is somewhat problematic, as in general we cannot establish the authenticity of either one.
To accomodate for this we distinguish between undirected (see figure \ref{fig:undirected-service-discovery}) and directed service discovery(see figure \ref{fig:directed-service-discovery}).
While the undirected discovery protocol is unauthenticated we are able to improve the situation for directed service discovery in certain cases.

Through a sidechannel we are able to retrieve additional data about a service we want to connect to.
As described by McCune et al. \cite{mccune2005seeing} we can establish additional trust amongst other things by scanning a QR code that is either printed on the case of the service or, further improving the trust level, by dynamically displaying a QR code on the screen.
This is particularly interesting in the case where we want to connect to a display service.
Upon notifying the service in a certain out-of-band way (e.g. by pressing a certain button on the display) it will generate a QR code and display it on the screen.
The client can subsequently scan the code and in such a way retrieve information like the public key and address of the display.
As soon as we have obtained data through this side channel we are able to verify authenticity of the service we are communicating with, assuming the side channel has not been compromised.

Let us now consider the actual discovery protocol.

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Service}

        \mess{c}{Discover}{s}
        \draw (Discover from) -- (Discover to) node[midway,below]
            {$sk_c(\text{version}, \text{listening port}) \| pk_c$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Announce}{c}
        \draw (Announce from) -- (Announce to) node[midway,below]
            {$pk_c(sk_s(\text{version}, \text{name}, \text{services} \| pk_s$)};

        \postlevel
    \end{sequencediagram}

    \caption{Undirected Service Discovery Messaging Chart}
    \label{fig:undirected-service-discovery}
\end{figure}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Service}

        \mess{c}{Discover}{s}
        \draw (Discover from) -- (Discover to) node[midway,below]
            {$pk_c(sk_s(\text{version}, \text{name}, \text{services} \| pk_s$)};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Announce}{c}
        \draw (Announce from) -- (Announce to) node[midway,below]
            {$pk_c(sk_s(\text{version}, \text{listening port}, \text{name}) \| pk_s$)};

        \postlevel
    \end{sequencediagram}

    \caption{Directed Service Discovery Messaging Chart}
    \label{fig:directed-service-discovery}
\end{figure}

\subsubsection{Handshake}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Server}

        \mess{c}{Probe}{s}
        \draw (Probe from) -- (Probe to) node[midway,below]
            {$pk_s(\text{Probe})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Service Description}{c}
        \draw (Service Description from) -- (Service Description to) node[midway,below]
            {$pk_c(\text{name}, \text{addresses}, \text{location}, \text{type}, \text{parameters}, \text{status})$};

        \postlevel
    \end{sequencediagram}
    \caption{Probe Messaging Chart}
\end{figure}

\subsubsection{Connection}

\begin{align*}
    \text{capability} \coloneqq pk_s(\text{sessionid}, \text{parameters})
\end{align*}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{c}{Client}
        \newinst[8]{s}{Server}

        \mess{c}{Connection Request}{s}
        \draw (Connection Request from) -- (Connection Request to) node[midway,below]
            {$pk_s(\text{parameters}, \text{secret})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Connection Capability}{c}
        \draw (Connection Capability from) -- (Connection Capability to) node[midway,below]
            {$pk_c(\text{sessionid}, \text{capability})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{c}{Connect}{s}
        \draw (Connect from) -- (Connect to) node[midway,below]
            {$pk_s(\text{sessionid}, \text{capability})$};

        \postlevel
        \postlevel
        \postlevel

        \mess{s}{Connect OK}{c}
    \end{sequencediagram}
    \caption{Direct Connect}
\end{figure}

\begin{figure}[H]
    \centering

    \begin{sequencediagram}
        \newinst{o}{Other Server}
        \newinst[4]{c}{Client}
        \newinst[4]{s}{Server}

        \mess{c}{Connection Request}{s}
        \postlevel
        \mess{s}{Connection Capability}{c}

        \postlevel
        \postlevel

        \mess{c}{Connection Request}{o}
        \postlevel
        \mess{o}{Connection Capability}{c}
        \postlevel
        \mess{c}{Connect}{o}

        \postlevel
        \postlevel

        \mess{o}{Connect}{s}
        \postlevel
        \mess{s}{Connect OK}{o}
    \end{sequencediagram}
    \caption{Relayed Connect}
\end{figure}

\subsection{Notes}

\begin{itemize}
    \item host has graphic server
    \item only knows about window extents, not contents due to encryption
    \item initially gets all keyboard/mouse inputs
    \item upon mouse enter inside a window, notifies mouse server of window extents
    \item mouse server keeps track of relative mouse position, notifies server upon exit of extents
    \item window server registers shortcuts that are required for window changing
    \item shortcuts may NEVER be rebound by client applications

    \item you can attach and reattach apps to other devices without any problems!!!
    \item overlay in server manager when app is connected and reqs are not fulfilled
    \item one container may run multiple apps
        \begin{itemize}
            \item clustering based on security level
        \end{itemize}
\end{itemize}

% vim: ft=tex tw=0
