\section{Discussion}

\subsection{Access control}

As one of the goals of the developed protocol is to be completely authenticated it is obvious that we have to perform some kind of access control to guard access to different services.
That is given a client with an identity connecting to a specific service, the service somehow needs to determine if the identity is acutally allowed to perform the desired action.

To discuss how access control is implemented, let us first explore how access control may be implemented in a theoretical view.
One of the easiest modes on how to perform access control is by using an access control matrix \cite{lampson1974protection,tanenbaum2014modern}.
The rows contain identities of users taking part in the protocol while columns represent different end-points a service exposes to the network.
In general, the rows are called \emph{subjects} while the columns are called \emph{objects}
Each entry in the matrix now determines which actions the client specified by the row is allowed to perform on the service's endpoint.

Each service provides two persistent end-points as well as an unbound number of ephemeral end-points.
The two persistent end-points provide the interface to query a service, that is obtain additional information on the service's specifica, and to request a new session within a service.
All sessions have their own set of permissions, as a session requested by Alice shouldn't be executable by Bob who just created another session.
As such, sessions can be treated as additional end-points and are thus added to the matrix as objects.

On each of these objects, subjects can perform a set of different actions, which currently only contain \emph{execute} and \emph{revoke}.
The \emph{execute} right allows a client to perform the action associated with that object.
This means executing a query for the query end-point, requesting sessions for the request end-point and executing the functionality provided by a session for sessions.
The \emph{revoke} right allows a client to remove rights for other subjects for the object the revoke right has been granted.

Table \ref{tab:access-control-matrix} provides an example for a typical access control matrix as it may be present for the developed protocol.
We assume three parties take part in the protocol, namely Alice, Bob and Carol, where each of these participants has his own long-term signature key pair.
The right to execute the given end-point is represented by the letter \emph{E} while the right to revoke permissions is represented by the latter \emph{R}.

The service is initially configured to only grant Alice the right to execute respectively revoke rights on the query and request end-points.
In an initial step, she requests a new session for Bob, which adds a column for the new object \emph{Session 1} to the access control matrix.
As Alice requested the session, she gains the permission to revoke permissions on the newly created object.
But given that the session is not created for Alice herself but instead for invocation by Bob, Alice has no right to execute the session, which is instead added to Bob.

The second step performed is that Alice grant Carol the right to query and request session on the service.
Carol now creates a new session herselves, which adds a newly created \emph{Session 2} to the matrix, granting Carol the right to revoke and execute the new object.

\begin{table}
    \centering
    \begin{tabular}{|c|c|c|c|c|}
        \hline
              & \bfseries Query & \bfseries Request & \bfseries Session 1 & \bfseries Session 2\\
        \hline
        \bfseries Alice & RE    & RE      & R         &\\
        \hline
        \bfseries Bob   &       &         & E         &\\
        \hline
        \bfseries Carol & E     & E       &           & RE\\
        \hline
    \end{tabular}

    \caption{Exemplary access control matrix}
    \label{tab:access-control-matrix}
\end{table}

One thing missing from the exemplary access control matrix is that services themselves may also take part in the protocol.
That is given two services \emph{A} and \emph{B}, A may use functionality provided by service B.
So in order to have a complete view of permissions, one would also add services instead of users only to the subjects.

The matrix only describes end-points for a single service.
In real-world scenarios the matrix would usually be much bigger by extending the columns by end-points provided by other services, as well.
Note that in this case, all end-points are namespaced to the service they belong to, e.g. the query end-point from service A is not the same as the query end-point from service B, so they may have different permissions.

% TODO: discuss adding rights

There are two commonly used distinct models how one can implement this matrix.
The first model is describing the table by its rows, that is each subject has assigned to it a set of (object,rights) pairs determining which objects may be accessed.
These pairs attached to the subjects of the matrix are named capabilities.
The other way to look at the matrix is by having a set of (subject,rights) pairs associated to the columns, which is called an access control list (ACL) \cite{tanenbaum2014modern}.
Both approaches result in a different set of characteristica for the system which we will now evaluate for our use case.

\subsubsection{Capabilities}

\cite{dennis1966programming}

Capabilities have been envisioned in 1966 by Dennis and van Horn \cite{dennis1966programming} in the context of multiprogrammed computations.
They provide a means of protecting system resources such as memory segments, input-output-devices or directories.
Each process owns a capability list (C-list), detailing which resources a process may access and what operations the process is allowed to perform on the described resource.
A benefit over conventional access control like ACLs is that processes have fine-grained control over these possessed capabilities in that they may share them with other processes if so desired.

In the 1970s, Wilkes, Needham et al. developed the first capability-using hardware with the Cambridge CAP Computer \cite{wilkes1979cambridge}.
In contrast to previous systems, which used base-limit registers to guard memory segments from unauthorized access, the CAP system used so-called capability registers.
In these capability registers, a process is able to store a capability describing a certain memory segment.
Attached to the capability is a special a bit-pattern used for authenticating the capability to the operating sysetm.

The bit-pattern stored inside the capability is required to be unforgable by user-space processes.
Only the operating system kernel may issue valid capabilities which are subsequently presented by the process wishing to access a specific memory segment.
On access of memory, hardware checks the processes capability registers to verify that it has the right to access it.
So obviously, these capabilities must be constructed in a way such that they are unforgable by all processes except by the operating system kernel itself, lest the system becomes insecure.

The CAP computer also manages peripherals through these capabilities by mapping them to special memory segments.
So when a process wants to access a peripheral device, it has to possess a capability for the segment corresponding to this device.
If the process is now allowed to access this segment, the operating systems grants it access to the peripheral device.
Like this, all resources are protected by the use of capabilities.

The implementation of the CAP capability system requires support by the operating system and hardware, though.
Capability systems usually need some kind of reference monitor, verifying access of resources via passed capabilities, watching how capabilities are passed between processes via passed capabilities and monitoring how capabilities are passed between processes
In distributed systems, though, these capabilities were not fit for user.

This restriction lead to the development of distributed capabilities.
The easy solution of just requiring every system to use capabilities which are then relayed through a network interface simply does not work, as adversarial users may simply run a modified kernel or operating system which circumvents capabilities in any way.
Also, there is shared hardware between distributed computers which is able to verify all memory access, so new solutions were developed.

In 1981, Donelley tries to lift this limitation and make capbilities fit for use in distributed environments \cite{donnelley1981managing}.
He defines the \emph{Distributed Domain Management Problem}, which consists of three parts:
\begin{enumerate}
    \item authorization by the service process
    \item communication of access between any pair of proceses
    \item validation by the service process
\end{enumerate}
Donelley then proceeds to lay out four mechanisms for how to protect capabilities and their accompanying benefits and detriments.

% TODO: details these mechanisms?

One of the first systems using capabilities for protection in distributed systems was the Amoeba operating system developed by Tanenbaum, Mullender et al. in 1986 \cite{tanenbaum1986using,mullender1990amoeba}.
Each service has a secret port $G$, called the get-port, and a corresponding public put-port $G$.
The put-port is computed by a one-way function $P = F(G)$ having the property that computing $P$ is efficient, but computing $G$ given $F$ is not feasible.
Clients willing to access the service can now send data to $P$, which may only be occupied by services who now the secret get-port $G$.

Amoeba relies on the assumption that every message sent via the network is transformed by this function $F$ and that it is impossible to circumvent, as otherwise an adversary may simply listen on the known public port $P$ without going through transformation of the $F$ function.
The authors mention two possiblities on how to achieve this: the clients either use a special trusted kernel which is able to perform the transformation, or the gateway to the local network will perform this transformation.
This fact alone makes Amoeba unusable in the age of the Internet, where it is impossible to control the heterogenous computing devices connected to it.

% TODO: capabilities based on encryption
% TODO: hybrid approach by \ref{gong1989secure}

\subsubsection{Access control lists}

% ACL: more centralized approach
%      easier maintainable by administrators
%      tracability

\subsubsection{Comparison to Kerberos}
\label{sec:kerberos}

Another system based on capabilities is the Kerberos protocol developed by Neuman et al. \cite{neuman1994kerberos,neuman2005rfc}, which provides a solution for network authentication based on capabilities.
Kerberos is the default method used for authentication in the Windows operating system and has implementations for Linux, BSD and Mac OS X.

Kerberos is built on a central authentication server (AS).
Whenever a client wants to connect to a service (S), it will get retrieve a ticket from the AS which the client can then present to S to authenticate itself to S.
See figure \ref{fig:kerberos-authentication} for the process of retrieving a ticket and authenticating to a service.

The initial step is for the client C to send a message to the AS, communicating that it wants to authenticatie to the server S.
This message contains a claimed identity, the identity of the server it wants to connect to and an expiry time until when the ticket shall be valid.
The AS will verify that C is allowed to connect to V and if so, will create a new session key which may be used to verify and encrypt traffic between C and V.

AS will now send a two-part message to the client:
Part one contains the session key as well as the expiry time and nonce chosen by the client, encrypted with a secret (in general a password) known to the client only.
The second part contains the ticket encrypted with a key shared between AS and S.
The ticket is used to verify that the client has been authorized by the AS and contains the session key shared between client and service, as well as the identity of the client.
As the key with which the ticket has been encrypted shall only be known by AS and S, the client would not be able to generate it by his own and should thus be sufficient to verify that the client has been authorized.

\begin{figure}[t]
    \centering

    \begin{subfigure}{0.45\textwidth}
        \begin{tikzpicture}[
                participant/.style={draw,circle,minimum size=3em},
                call/.style={draw, -triangle 45}
            ]
            \node[participant] (c) {C};
            \node[participant,right=3.0cm of c] (s) {S};
            \node[participant,above=1.0cm of c,xshift=2.0cm]  (as) {AS};

            \draw[call] (c.55) -- node[above left] {1} (as.215);
            \draw[call] (as.235) -- node[below right] {2} (c.35);
            \draw[call] (c.0) -- node[below] {3} (s.180);
        \end{tikzpicture}
        \subcaption{Kerberos authentication}
        \label{fig:kerberos-authentication}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth}
        \begin{tikzpicture}[
                participant/.style={draw,circle,minimum size=3em},
                call/.style={draw, -triangle 45}
            ]
            \node[participant] (c) {C};
            \node[participant,right=3.0cm of c] (s) {S};
            \node[participant,above=1.0cm of c,xshift=2.0cm]  (cs) {CS};
            \node[participant,above=1.0cm of s] (p) {P};

            \draw[call] (c.55) -- node[above left] {1} (cs.215);
            \draw[call] (cs.10) -- node[above] {2} (p.170);
            \draw[call] (p.280) -- node[right] {3} (s.80);
            \draw[call] (s.100) -- node[left] {4} (p.260);
            \draw[call] (p.190) -- node[below] {5} (cs.350);
            \draw[call] (cs.235) -- node[below right] {6} (c.35);
            \draw[call] (c.0) -- node[below] {7} (s.180);
        \end{tikzpicture}
        \subcaption{Protocol authentication}
        \label{fig:protocol-authentication}
    \end{subfigure}

    \caption{Authentication}
    \label{fig:authentication}
\end{figure}

The generated ticket is a kind of capability in that it allows a client to access a service without further requests to the authentication server.
The receiving server will simply check the ticket's cryptographically protected content and can thus verify that it is actually a valid ticket.
As it also contains information on the client, services will always know to whom the ticket has been issued.
But note that in theory, clients may pass on tickets to other entities as the connection step to the service does not include another verification of the client's identity.

We can directly compare the basic Kerberos authentication protocol with the developed session protocol.
To simulate the scenario of a central authentication server, we can set up a capability service.
With a capability service, a client may ask the capability service to create a new session with another service in the name of the capability service.
See section \ref{sec:capability-service} for more information on how the capability service is implemented.

The setup is such that we have a domain-wide capability service which is well-known to all clients of the domain and accessible by all clients to request permissions to connect to a service.
On the other hand, only a certain client is allowed to connect to the capability service in order to implement the policy.
This client will register with the capability service and subsequently receives all requests by clients wishing to gain access to a specific service.
This policy client may either have an internal list of clients that are allowed to connect to certain services or, for example in corporate environments, connect to an Active Domain Directory Service to determine the control policies.

Let us now consider figure \ref{fig:protocol-authentication} to see how our protocol compares to the Kerberos protocol.
When an actual client C wants to connect to a service S, he will first make a request with the capability service CS.
This request contains to whom C wants to connect to (S), and how the connection shall look like (as the parameters with which C onnects to S later on are passed on to CS).
CS will now forward this request to the policy-implementing client P.
Based upon the the identities of C and S, as well as based upon the connection parameters, P may now decide if the connection is a legitimate one and if so, request a new session with S.
This new session may be revoked by P and executed by C, only.
The session information is now passed back to C via CS, where C may now connect to S.

On first sight, our protocol requires much more communication between parties than the Kerberos protocol.
We note though that the policy-implementing client P can easily remain on the same local server as the capability service CS, and as such the overhead will reduce to a call on the same host.
The authentication server in the Kerberos protocol will usually have to perform lookups himself in order to determine wether C is allowed to connect.
Theoretically, it would be possible to have the CS implement the policy directly, without requiring to call out to P.
This specialized service would reduce the indirection via P and reduce the calls required to 5 instead of 7 calls.

One weakness of the Kerberos protocol as compared to our protocol is that the AS generates the session keys which are later on used to communicate between client and server.
If the AS is not fully trusted by clients (which it is assumed to be in the Kerberos protocol), it may easily compromise the connection between C and S.
In our protocol there is no way for the CS to eavesdrop on the connection between C and S at any time, as all encryption is done via an ephemeral encryption key that is generated anew on each connection.

\bigskip

Kerberos also has the notion of ticket-granting tickets.
That is when a client initially connects to an AS, he will typically not request a ticket for single usage but instead a ticket which grants the client the ability to request further ticktes without the requirement to re-authenticate himselves with the user's secret.
This ticket-granting ticket (TGT) can subsequently be presented to a ticket-granting service (TGS) whenever the client wishes to connect to a service.
The TGS will verify the TGT is actually valid and output a new ticket for use with the desired service.

Currently, this is not possible for our protocol as upon each connection, the client has to perform the initial handshake which requires him to have access to the long-term signature key pair representing his identity.
Considering the key pair is currently unprotected, there is no need to insert the password again, which is an obvious shortcoming and should be fixed by encrypting the key pair.
As soon as the key is encrypted, there may be a solution similar to the Secure SHell (SSH) where an agent caches the key pair in memory upon first decryption so the user is not required to re-input his passphrase on each connection.
Considering the TGT still requires communication with the TGS to get new tickets, our implementation would not perform much worse when requesting sessions with the CS.

The mechanism of TGTs requires further thought about revokability of tickets.
In Kerberos, each ticket has an expiry date after which it becomes invalid.
This expiry date is chosen by the client and put into the ticket by the AS, which requires loosely-synchronized network times.
By default, this expiry time is set to 5 minutes for simple tickets and to 8 hours for ticket-granting tickets.

For simple tickets there is no mechanism for invalidating this ticket.
This limitation results from the fact that these tickets are implemented as capabilities where no further communication with the AS is required in order to accept a ticket presented by connecting clients.
To solve this problem, the AS would be required to tell every service accepting tickets issued by the AS to invalidate a compromised ticket.
So in fact stolen tickets will be a security threat for at most 5 minutes.

For TGTs, where the expiry date is set to 8 hours, this would be unacceptable.
To counteract the scenario of a stolen TGT, the TGS has a hot-list of tickets that have been compromised and will thus be rejected.

For our protocol, no such mechanism is required.
The first hurdle is that sessions cannot be invoked by any other identity than the owner of the long-term signature key pair for whom the session has been created.
If such a key pair has been compromised, it is possible to revoke sessions by either the session creator (e.g. the policy client of the CS) or the session's invoker.

\subsubsection{Mobile client}

The protocol is designed to be usable by mobile clients, as well.
E.g. given a scenario that a user wants to display the graphical interface of an executable running at his trusted home server on a local display, he may simply start up the mobile client which has previously been paired with the home server to connect these services with one another.

One problem with mobile clients is that they are inherently less safe than servers located at ones home or in datacenters.
It is much easier to loose or have stolen a mobile phone or tablet than to loose a full desktop computer.
Even when the device has full disk encryption enabled, unlocking the contents is usually only a 4-digit pincode away.
Due to this consideration, many a user does not want to store highly sensitive data like his long-term signature key on the device.

Fortunately, the protocol allows for the scenario where the mobile client is not required to know the actual long-term signature key but still connect to service requiring this key, required the user has access to a trusted server.
The setup required is similar to the setup presented in section \ref{sec:kerberos} on Kerberos.
Given the long-term signature key of the mobile client, which is distinct from the user's actual long-term signature key, he sets up a capability server on his home server.
Connected to the capability server is a simple policy client which grants all session requests from the mobile client's public signature key.
The policy client has access to the actual key pair and will use it for requesting the desired sessions.

So whenever the mobile client wishes access to a service in the name of his actual long-term signature key, he will simply request the capability service to request a new session with his actual key.
The policy client will accept the request when it is the mobile client's key, create a new session for the required service and forward the session to the mobile client.
The mobile client may now use the session.

Like this, only a single instance is required to know the actual key.
This instance shall obviously be protected so that no person has access to it and may extract the key.
Still, loss of the key is much harder than loss when the key is distributed to several clients, including mobile clients.

% vim: ft=tex tw=0
